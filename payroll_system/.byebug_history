c
response.body
response.status
c
response.body
c
response.body
response.status
c
response.body
c
response.body
response.status
c
response.body
response.status
c
response.body
response
response.body
response.status
c
response
response.body
response.status
c
user
status: 201
status(201)
response.body
response.status
c
@user
c
User
@user
c
User
c
@user
c
@user
c
@user = User.all.where(id: @user.id).as_json(except: %i[created_at updated_at jwt role_id],
   64:                                                  include: ['role' => { only: :role_type }])
@user
c
current_user
@user
c
@user
c
response.status
response.body
response
c
response.status
response
:find_user_info
:find_user_info.class
:find_user_info
:find_user_info.new
get
get :find_user_info
:find_user_info
c
expect{response}.to raise_error(ActiveRecord::RecordInvalid)
response.status
response
c
Faker::Number.within(range: 4..10)
id
c
id: Faker::Number.within(range: 4..10)
id
response.status
response
c
response.status
response
c
admin_user
c
response
response.status
get :index
:index
c
admin_user
c
attendance2
c
expect(leave_balance3.valid?).to eq(false)
leave_balance3.valid?
leave_balance2.valid?
c
expect{leave_balance3.valid?}.to eq(false)
c
expect{leave_balance3.valid?}.to eq(false)
c
leave_balance3.valid?
leave_balance2.valid?
leave_balance2.valid
leave_balance2
c
leave_balance3.valid?
leave_balance3
c
leave_balance2
leave_balance3
c
get :index
ger :index
:index
c
sign_in(user)
response.body
user
@user
c
user2.save!
user2.save
user
c
user.salaries.find_by(salary_month: params[:payslip][:slip_month])
sal_attend
c
sal
@attend
@sal
c
unpaid_intial_value
unpaid_initial_value
paid_initial_value
c
total_duration
c
total_duration
c
total_duration
c
total_duration
c
total_duration
c
month_leave
c
@leave.where("(start_date BETWEEN ? AND ?) OR (end_date BETWEEN ? AND ?)", attendance_date.beginning_of_month,
    attendance_date.end_of_month, attendance_date.beginning_of_month,attendance_date.end_of_month)
c
month_leave
c
@leave.where("(start_date BETWEEN ? AND ?) OR (end_date BETWEEN ? AND ?)", attendance_date.beginning_of_month,
    attendance_date.end_of_month, attendance_date.beginning_of_month,attendance_date.end_of_month)
attendance_date.beginning_of_month
c
@leave.where("cast(strftime('%M', start_date) as int) = ?", attendance_month)c
@leave.where("cast(strftime('%M', start_date) as int) = ?", attendance_month)
a
a = @leave.where(start_date: "2023-02-09")
a = @leave.where("start_date" = "2023-02-09")
@leave
month_leave
c
"cast(strftime('%M', start_date) as int) = ?", attendance_month
attendance_month
c
cc
c
@leave
@leave.start_date
@leave.where("cast(strftime('%M', start_date) as int) = ?", attendance_month)
c
month_leave
c
attendance_month
c
attendance_date
c
active_leaves
c
active_leaves.leave_duration
active_leave.leave_duration
active_leaves.class
active_leaves.type
active_leaves
c
active_leaves
c
paid_array
c
active_leaves.where(leave_type: "Paid")
paid_array
c
active_leaves.where(leave_type: "Paid")
active_user.where(leave_type: "Paid")
active_leaves.where(leave_type: "Unpaid")
active_leaves
c
user.leave_balances
active_leaves
active_leaves.where(leave_type: "Unpaid")
active_leaves
c
unpaid_array
c
unpaid_array
active_user
c
unpaid_array
c
active_user
c
user.leave_balances.where(leave_duration: "Active")
c
unpaid_final_value
c
unpaid_excess_value
unpaid_intial_value
unpaid_final_value
unpaid_excess_value
c
paid_initial_value
paid_intial_value
unpaid_excess_value
c
@tot_paid_leaves
c
@tot_paid_leaves
unpaid_intial_value
c
paid_initial_value
c
unpaid_intial_value
c
@leave_sum
c
@leave_sum
c
user.leave_balances.where(leave_type: "Paid")
c
user.leave_balances.where(leave_type: "Unpaid")
c
params
c
params
c
user.leaves
user.leaves=
user.leave
user.leaves
user.leaves.where(leave_type: "Unpaid")
attendance
user
c
load_and_authorize_resource
